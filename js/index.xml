<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Js on Website of Acha</title>
    <link>https://achah.github.io/js/</link>
    <description>Recent content in Js on Website of Acha</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 21 Sep 2020 21:34:25 +0800</lastBuildDate>
    
	<atom:link href="https://achah.github.io/js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>防抖和节流</title>
      <link>https://achah.github.io/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 21 Sep 2020 21:34:25 +0800</pubDate>
      
      <guid>https://achah.github.io/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid>
      <description>JavaScript 中的节流和防抖  防抖和节流都是在解决高频触发的或后台连续请求的优化逻辑问题
 防抖和节流的核心就是定时器。
 防抖&amp;gt;你不停止我就不执行，节流&amp;gt;间隔固定时间执行。
 防抖和节流 防抖函数的作用就是控制函数在一定的事件内的执行次数。防抖意味着触发高频事件后n秒内函数只会执行一次（最后一次），如果n秒内高频事件再次被触发，则重新计算延迟时间。</description>
    </item>
    
    <item>
      <title>Js基础总结</title>
      <link>https://achah.github.io/js/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 06 Sep 2020 16:47:18 +0800</pubDate>
      
      <guid>https://achah.github.io/js/js%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</guid>
      <description>js基础总结 javaScript是什么  javaScript是一种运行在客户端（浏览器）的脚本语言
 脚本语言：不需要编译，读取一句 解析一句 一句报错 下一句就不会执行； 执行过程：源代码 - 预解析 - 运行； 编译语句：需要编译，编译一旦出错 整个程序都不会运行 执行过程：源代码-编译后的字节码文件-运行 变量  变量的规则和规范</description>
    </item>
    
    <item>
      <title>This指向问题</title>
      <link>https://achah.github.io/js/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 28 Aug 2020 17:11:12 +0800</pubDate>
      
      <guid>https://achah.github.io/js/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</guid>
      <description>this指向问题以及如何改变 指向问题  一般函数中this指向window。 对象中函数的this指向，他的this是调用该函数的实例对象 构造函数里的this，指向创建出来的实例 事件处理函数中，他的this指向触发事件的元素 箭头函数没有自己的this，它的this指向上下文中的this，即所处环境的this  函数名(); ==&amp;gt; 属于函数调用模式，函数内的this指向window new Person(); ==&amp;gt; 构造函数中的this指向了新创建的实例对象 方法调用模式 （对象中的函数称之为方法）==&amp;gt; obj.</description>
    </item>
    
  </channel>
</rss>